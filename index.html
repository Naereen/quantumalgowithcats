<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<script type="text/javascript" src="distribution.js"></script>
	<script type="text/javascript"
		src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body>
	<h1>Quantum computing explained with cats</h1>


	$$\newcommand{\ket}[1]{\mid#1 \rangle}$$

	<h2>Bits as cats</h2>
	A bit can be either 0 or 1. Let us represent them by cats:

	<example>
		bit = 0 <img class="qubit" src="cat1_dead.png"> </example>
	<example> bit = 1 <img class="qubit" src="cat1_alive.png"></example>

	<h3>Qubits</h3>
	Qubits are quantum bits. They are also represented by cats, but they can be in a superposed state. For instance:



	<example> <img class="qubit" src="cat1_dead.png"> is the qubit equal to 0. This state is denoted by |0>.</example>
	<example> <img class="qubit" src="cat1_alive.png"> is the qubit equal to |1>.</example>

	<example>
		<img class="qubit" id="example_superposition" src="cat1_dead.png"> may represent the superposition $$\frac 1
		{\sqrt 2} (\ket 0 +
		\ket 1)$$ where the qubit is at |0> with probability 1/2 and at |1> with probability 1/2.
	</example>


	<example>
		<img class="qubit" id="example_superposition_1434" src="cat1_dead.png"> may represent the superposition $$\frac
		1 2 \ket 0 + \frac
		{\sqrt 3} 2 \ket 1)$$ where the qubit is at |0> with probability 1/4 and at |1> with probability 3/4.
	</example>


	<h3>Two qubits</h3>

	<example>
		<img id="example_superposition_2_bit1" src="cat1_dead.png"><img id="example_superposition_2_bit2"
			src="cat2_dead.png"> may represent the superposition $$\frac 1 2 (\ket {00} + \ket {01} + \ket {10} + \ket
		{11})$$ where all states |00>, |01>, |10> and |11> have probability 1/4.
	</example>

	<example>
		<img id="example_superposition_bellstate_bit1" src="cat1_dead.png"><img
			id="example_superposition_bellstate_bit2" src="cat2_dead.png"> is a <a
			href="http://en.wikipedia.org/wiki/Bell_state">Bell state</a>: it may be the
		superposition $$\frac 1 {\sqrt 2} (\ket {00} + \ket {11})$$ where we have |00> with probability 1/2 and |11>
		with
		probability 1/2. There is <a href="http://en.wikipedia.org/wiki/Quantum_entanglement">entanglement</a>.
	</example>


	<h3>Note: in fact numbers are complex numbers</h3>
	For instance, if the scalar is negative,
	images are turned.

	<example>
		<img src="cat1_alive_down.png"> may represent the superposition -|1>.
	</example>

	<h2>Grover's algorithm</h2>




	<table>
		<tbody>
			<tr>
				<td>
					<img id="superposition0_bit1" style="" src="cat1_alive.png"><br />
					<img id="superposition0_bit2" src="cat2_alive.png"><br />
					<img id="superposition0_bit3" src="cat3_alive.png"><br />
					<img id="superposition0_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img src="gateH.png"><br />
					<img src="gateH.png"><br />
					<img src="gateH.png"><br />
					<img src="gateH.png">
				</td>
				<td>
					<img id="superposition1_bit1" src="cat1_alive.png"><br />
					<img id="superposition1_bit2" src="cat2_alive.png"><br />
					<img id="superposition1_bit3" src="cat3_alive.png"><br />
					<img id="superposition1_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img src="gatef.png">
				</td>
				<td>
					<img id="superposition2_bit1" src="cat1_alive.png"><br />
					<img id="superposition2_bit2" src="cat2_alive.png"><br />
					<img id="superposition2_bit3" src="cat3_alive.png"><br />
					<img id="superposition2_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img src="gateD.png">
				</td>
				<td>
					<img id="superposition3_bit1" src="cat1_alive.png"><br />
					<img id="superposition3_bit2" src="cat2_alive.png"><br />
					<img id="superposition3_bit3" src="cat3_alive.png"><br />
					<img id="superposition3_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img src="gatef.png">
				</td>
				<td>
					<img id="superposition4_bit1" src="cat1_alive.png"><br />
					<img id="superposition4_bit2" src="cat2_alive.png"><br />
					<img id="superposition4_bit3" src="cat3_alive.png"><br />
					<img id="superposition4_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img src="gateD.png">
				</td>
				<td>
					<img id="superposition5_bit1" src="cat1_alive.png"><br />
					<img id="superposition5_bit2" src="cat2_alive.png"><br />
					<img id="superposition5_bit3" src="cat3_alive.png"><br />
					<img id="superposition5_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img src="gatef.png">
				</td>
				<td>
					<img id="superposition6_bit1" src="cat1_alive.png"><br />
					<img id="superposition6_bit2" src="cat2_alive.png"><br />
					<img id="superposition6_bit3" src="cat3_alive.png"><br />
					<img id="superposition6_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img src="gateD.png">
				</td>
				<td>
					(*)
					<img id="superposition7_bit1" src="cat1_alive.png"><br />
					<img id="superposition7_bit2" src="cat2_alive.png"><br />
					<img id="superposition7_bit3" src="cat3_alive.png"><br />
					<img id="superposition7_bit4" src="cat4_alive.png"><br />
				</td>
				<td>
					<img src="gatef.png">
				</td>
				<td>
					<img id="superposition8_bit1" src="cat1_alive.png"><br />
					<img id="superposition8_bit2" src="cat2_alive.png"><br />
					<img id="superposition8_bit3" src="cat3_alive.png"><br />
					<img id="superposition8_bit4" src="cat4_alive.png">
				</td>
				<td>
					<img src="gateD.png">
				</td>
				<td>
					(**)
					<img id="superposition9_bit1" src="cat1_alive.png"><br />
					<img id="superposition9_bit2" src="cat2_alive.png"><br />
					<img id="superposition9_bit3" src="cat3_alive.png"><br />
					<img id="superposition9_bit4" src="cat4_alive.png"><br />
				</td>
			</tr>
		</tbody>
	</table>






	<h3>Few words about Grover's algorithm</h3>
	Grover's algorithm is solving the following problem. Let f be a
	function from {0, 1}^n to {0, 1}. Here n = 4. We pose N = 2^n. Here N =
	16. There is a unique element x such that f(x) = 1. In our example, x is 0101 that is


	<img src="cat1_dead.png">
	<img src="cat2_alive.png">
	<img src="cat3_dead.png">
	<img src="cat4_alive.png">.</br>
	</br></br>

	The aim is to find x without any knowledge on f. More precisely, the problem solved by Grover's algorithm is defined
	as follows:
	</br>
	- input: a black box Uf that computes f;
	</br> - output: x such that f(x) = 1.
	<br /><br />
	Grover's starts with 0000, that is <img src="cat1_dead.png"><img src="cat2_dead.png"><img src="cat3_dead.png"><img
		src="cat4_dead.png">. Then we apply <a href="http://en.wikipedia.org/wiki/Hadamard_transform">Hadamard gates</a>
	in order to obtain a uniform superposition of all physical states. Then
	we apply the gate Uf. It preserves all physical states except |0101>. The
	state |0101> is mapped to -|0101>.

	</br></br></br>

	Examples:
	</br></br>

	<table>
		<tr>
			<td>
				<img src="cat1_alive.png"><br />
				<img src="cat2_alive.png"><br />
				<img src="cat3_dead.png"><br />
				<img src="cat4_alive.png">
			</td>
			<td>
				<img src="gatef.png">
			</td>
			<td>
				<img src="cat1_alive.png"><br />
				<img src="cat2_alive.png"><br />
				<img src="cat3_dead.png"><br />
				<img src="cat4_alive.png">
			</td>
		</tr>
	</table>

	</br></br>

	<table>
		<tr>
			<td>
				<img src="cat1_dead.png"><br />
				<img src="cat2_alive.png"><br />
				<img src="cat3_dead.png"><br />
				<img src="cat4_dead.png">
			</td>
			<td>
				<img src="gatef.png">
			</td>
			<td>
				<img src="cat1_dead.png"><br />
				<img src="cat2_alive.png"><br />
				<img src="cat3_dead.png"><br />
				<img src="cat4_dead.png">
			</td>
		</tr>
	</table>

	</br></br>

	<table>
		<tr>
			<td>
				<img src="cat1_dead.png"><br />
				<img src="cat2_alive.png"><br />
				<img src="cat3_dead.png"><br />
				<img src="cat4_alive.png">
			</td>
			<td>
				<img src="gatef.png">
			</td>
			<td>
				<img src="cat1_dead_down.png"><br />
				<img src="cat2_alive_down.png"><br />
				<img src="cat3_dead_down.png"><br />
				<img src="cat4_alive_down.png">
			</td>
		</tr>
	</table>










	Then D is the Grover diffusion
	operator that amplifies the unique state that has a negative scalar and put a positive scalar on it that is stricly
	greater in norm that the previous scalar. The other states are such that their probability are lower. In other
	words, the state |0101> is amplified.


	When we then apply again the Uf operator, we continue to negate the scalar of |0101> and the other scalars are kept
	equal. Then D continues to amply more and more the scalar of |0101> in norm.
	After some iterations of Uf
	and D, we may measure the qubits and obtain |0101> with a probability
	higher than 1/2: at (*) in the circuit the measure is ideal.
	<br /><br /><br />
	Warning: if we do too much iterations, then the probability is then again decreasing. For instance, (**) in the
	circuit is already too late.
	<br /><br />


	<script>
		//frames per second
		var FPS = 5;


		/*returns a superposition of 4 qubits where each state has probability 1/rac 16*/
		function generateHnsuperposition() {
			superposition = new Distribution();
			for (var b1 = 0; b1 <= 1; b1++)
				for (var b2 = 0; b2 <= 1; b2++)
					for (var b3 = 0; b3 <= 1; b3++)
						for (var b4 = 0; b4 <= 1; b4++)
							superposition.push({ bit1: b1, bit2: b2, bit3: b3, bit4: b4, alpha: 1 / 16 }, 1 / 16);

			return superposition;
		}

		/*the unique element x such that f(x) = 1*/
		var magicElement = { bit1: 0, bit2: 1, bit3: 0, bit4: 1 };




		/*generate the state where the magic Element is weighted by a and other elements are weighted by b*/
		function generateStateWithMagicElement(a, b) {
			superposition = new Distribution();
			for (var b1 = 0; b1 <= 1; b1++)
				for (var b2 = 0; b2 <= 1; b2++)
					for (var b3 = 0; b3 <= 1; b3++)
						for (var b4 = 0; b4 <= 1; b4++) {
							if ((b1 == magicElement.bit1) &&
								(b2 == magicElement.bit2) &&
								(b3 == magicElement.bit3) &&
								(b4 == magicElement.bit4))
								superposition.push({ bit1: b1, bit2: b2, bit3: b3, bit4: b4, alpha: a }, Math.pow(a, 2));
							else {
								superposition.push({ bit1: b1, bit2: b2, bit3: b3, bit4: b4, alpha: b }, Math.pow(b, 2));

							}
						}

			return superposition;
		}


		/*generate the superposition where the state is completely determined (its weight = 1)*/
		function generateSuperpositionUniqueState(b1, b2, b3, b4) {
			superposition = new Distribution([]);
			superposition.push({ bit1: b1, bit2: b2, bit3: b3, bit4: b4, alpha: 1 }, 1);
			return superposition;
		}




		/*parameters of Grover's algorithm*/
		var N = 16; //2^(nb of qubits)
		var theta = Math.asin(1 / Math.sqrt(N));

		/*a(k) and b(k) are the weight of respectively the magic element and the others elements in the superpositions of the Grover's algorithm*/
		function a(k) {
			return Math.sin((2 * k + 1) * theta);
		}


		function b(k) {
			return (1 / Math.sqrt(N - 1)) * Math.cos((2 * k + 1) * theta);
		}




		//alert(a(0));
		//alert(b(0));

		/*the superpositions in the circuit*/
		var superpositions = new Array();
		superpositions[0] = generateSuperpositionUniqueState(0, 0, 0, 0);
		superpositions[1] = generateHnsuperposition();
		superpositions[2] = generateStateWithMagicElement(-a(0), b(0));
		superpositions[3] = generateStateWithMagicElement(a(1), b(1));
		superpositions[4] = generateStateWithMagicElement(-a(1), b(1));
		superpositions[5] = generateStateWithMagicElement(a(2), b(2));
		superpositions[6] = generateStateWithMagicElement(-a(2), b(2));
		superpositions[7] = generateStateWithMagicElement(a(3), b(3));
		superpositions[8] = generateStateWithMagicElement(-a(3), b(3));
		superpositions[9] = generateStateWithMagicElement(a(4), b(4));




		/*returns "_down" if the weight of the state is negative and "" else*/
		function downifnegative(state) {
			if (state.alpha < 0)
				return "_down";
			else
				return "";
		}



		function getAliveOrDead(bit) {
			if (bit)
				return "_alive";
			else
				return "_dead";
		}

		/*the loop of the animation*/
		function loop() {
			/*we update all the superpositions in the circuit*/
			for (var i = 0; i <= 9; i++) {
				state = superpositions[i].peekRandom();

				window.document.getElementById("superposition" + i + "_bit1").src =
					"cat1" + getAliveOrDead(state.bit1) + downifnegative(state) + ".png";
				window.document.getElementById("superposition" + i + "_bit2").src =
					"cat2" + getAliveOrDead(state.bit2) + downifnegative(state) + ".png";
				window.document.getElementById("superposition" + i + "_bit3").src =
					"cat3" + getAliveOrDead(state.bit3) + downifnegative(state) + ".png";
				window.document.getElementById("superposition" + i + "_bit4").src =
					"cat4" + getAliveOrDead(state.bit4) + downifnegative(state) + ".png";

			}

			/*we update the superpositions in the explanation*/
			window.document.getElementById("example_superposition").src = "cat1" + getAliveOrDead(Math.random() < 0.5) + ".png";
			window.document.getElementById("example_superposition_1434").src = "cat1" + getAliveOrDead(Math.random() < 0.75) + ".png";

			var b = Math.random() < 0.5;
			window.document.getElementById("example_superposition_bellstate_bit1").src = "cat1" + getAliveOrDead(b) + ".png";
			window.document.getElementById("example_superposition_bellstate_bit2").src = "cat2" + getAliveOrDead(b) + ".png";

			window.document.getElementById("example_superposition_2_bit1").src = "cat1" + getAliveOrDead(Math.random() < 0.5) + ".png";
			window.document.getElementById("example_superposition_2_bit2").src = "cat2" + getAliveOrDead(Math.random() < 0.5) + ".png";
			setTimeout("loop()", 1000 / FPS);
		}

		loop();

	</script>

</body>

</html>